### C4430:  missing type specifier - int assumed. Note: C++ does not support default-int (with) note: see reference to class template instantiation '...' being compiled
Related to (C2061).

```cpp
template <typename Value>
struct some_class : public base_class<Impl>

    void update(const Value& v, const update_predicate_type& pred) override
                                           ^^^^^^^^^^
    {
        //...
    }
};
```

#### Description:
A type defined in a template base class is no longer automatically inherited. Here, `update_predicate_type` is defined in the `base_class<Impl>`. But since `base_class` is a template, it's types and members are no longer automatically introduced into the `some_class` scope.

#### Solution:
Use a `using` directive to include the missing type definition in the `some_class` scope
```cpp
template <typename Value>
struct some_class : public base_class<Impl>

    // "inherit" / introduce the `update_predicate_type` identifier from the base_class
    using update_predicate_type = base_class<Impl>::update_predicate_type;

    void update(const Value& v, const update_predicate_type& pred) override
    {
        //...
    }
};
```
