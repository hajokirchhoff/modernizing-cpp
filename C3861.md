### C3861: 'xx': identifier not found (with) note: see reference to class template instantiation 
This can mean several things.

```cpp
template <typename Iterator, typename Visitor>
struct json_object :public qi::grammar<Iterator, space_type>
{
    json_object(Visitor &v) :base_type(object_), v_(&v)
                              ^^^^^
    {
    ...
    }
}
```

#### Description:
`base_type` is declared in the base class `qi::grammar<...>`of this template. Previously, with `/permissive`, this was found automatically, because the compilers name lookup would also look for names in a *dependend base class*. Here, `qi::grammar<...>` is a *dependend base class*, because it *depends*  on the template argument. 

#### Solution:
Use the fully qualified name or add a `using` statement to explicitly specify that you mean the `base_type` type of the base class.
```cpp
template <typename Iterator, typename Visitor>
struct json_object :public qi::grammar<Iterator, space_type>
{
    using base_type = qi::grammar<Iterator, space_type>;
    json_object(Visitor &v) :base_type(object_), v_(&v)
    {
    ...
    }
}
```


### Details:
The problem is that the base class is a template and could have specializations that do not have a type named `base_type`. In that case, `base_type` could mean something else entirely. IOW, it depends on the template parameters of the base class if `base_type` is part of the base class or not.

[Look up members in dependent base class](https://docs.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170#look-up-members-in-dependent-base)

---

### C3861: 'xx': identifier not found (with) note: function was not declared in the template definition context
Similar problem like above, except not with a type, but with a function call instead.
```cpp
template <typename Char>
struct sample_rate_units_p : public boost::spirit::qi::symbols<Char, izt::types::units::sample_rate_units>
{
    sample_rate_units_p()
    {
        using namespace izt::types::units;
        using boost::algorithm::to_lower_copy;
        add
        ^^^
            (to_lower_copy(unit_as_string<Char>(Sps)), Sps)
``` 
### Description:
The function `add` in the example is declared in the base class `spirit::qi::symbols<...>`. Previously the compiler would accept that and call `symbols<...>::add`. For the same reasons explained above this is not allowed in the C++ standard.

### Solution:
You could add the `base_class` in front of it `base_class::add`, but in these cases it is also possible to use `this->add..`. This makes it clear that you expect `add` to be defined either in the class itself or in one of it's base classes. The statement also makes it clear that `add` is not a free function.
```cpp
template <typename Char>
struct sample_rate_units_p : public boost::spirit::qi::symbols<Char, izt::types::units::sample_rate_units>
{
    sample_rate_units_p()
    {
        using namespace izt::types::units;
        using boost::algorithm::to_lower_copy;
        this->add
        ^^^
            (to_lower_copy(unit_as_string<Char>(Sps)), Sps)
``` 

---
### C3861: 'xx': identifier not found ( - else - )
If the error is none of the above it may simply that a `using namespace` is missing or no longer active with "/permissive-" or that a base or dependent class no longer allows type lookup for the identifier.

#### Description:
```cpp
template <typename Socket, typename YieldContext>
void handshake_response(Socket &s, boost::system::error_code &error, YieldContext yield)
{
    boost::asio::deadline_timer dt(s.IZTCPP_GET_BOOST_IO_SERVICE());
    dt.expires_from_now(initial_handshake_timeout);
    dt.async_wait(boost::bind(&binary_message_protocol::handshake_error<Socket>, this, boost::ref(s), boost::ref(error), _1));
                                                                                                                         ^^
```

Here, `_1` is a placeholder. With "/permissive" the compiler could deduce that `_1` refers to `boost::placeholders::_1`. Now, with \<ConformanceMode\> this is no longer possible.

#### Solution:
Use the fully qualified name `boost::placeholders::_1`
