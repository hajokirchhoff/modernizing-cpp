### error C2440: '\<function-style-cast\>': cannot convert from 'initializer list' to '_litwindow\::odbc\::sqldiag_'
This can happen in several cases. Here the `initializer list` is the problem.

> ...litwindow\libs\odbc\lwodbc.cpp(202): error C2440: '\<function-style-cast\>': cannot convert from 'initializer list' to 'litwindow\::odbc\::sqldiag'<br>
> ...\litwindow\libs\odbc\lwodbc.cpp(202): note: No constructor could take the source type, or constructor overload resolution was ambiguous
#### Description:
The code is trying to create an object of type `sqldiag`, but there is no constructor that accepts the `initializer list` (the parameters).

```cpp
.h
struct sqldiag {
   sqldiag(char p_state[5], SQLINTEGER p_native_error, const string &p_msg);
};

.cpp
   sqldiag value("LWODB", err_logic_error, "<<Logic error: Requested diagnostics record does not exist!>>");
```
What seems suprising is that this code compiles just fine with `/permissive-`. What is going on?

sqldiag has a constructor that accepts an array of 5 chars ```char p_state[5]```. The code tries to call it with a null terminated string literal "LWODB".

#### Solution:
Change the constructor from `char p_state[5]` to a `const char p_state[5]`.

String literals are actually of type `const char *`, not `char *`. This makes sense, since string literals are not supposed to be modified. But earlier versions of the compiler or the `/permissive` switch allow this anyway.

Now, with `/permissive-` this is no longer allowed. Thus the compiler sees a string literal (`const char *`), looks for a constructor but does not find one. The existing constructor wants a `char *`, which no longer matches, causing the error "cannot convert ...  No constructor could take the source type..."


```cpp
struct sqldiag {
   sqldiag(const char p_state[5], SQLINTEGER p_native_error, const string &p_msg);
};
```

### error C2440: '\<function-style-cast\>': cannot convert from 'initializer list' to '_litwindow\::odbc\::sqldiag_'
This can happen in several cases. Here the temporary parameter is the problem.
> C2440: 'default argument': cannot convert from 'context_ptr_t' to 'context_ptr_t &'
>... note: A non-const reference may only be bound to an lvalue

#### Description:
The code is trying to pass a temporary object to a parameter that only accepts a reference.
```cpp
checkout_request(context_ptr_t &local_context = context_ptr_t())
{
    m_local_context= local_context;
}
```
`context_ptr_t()` is the default parameter of the function `checkout_request`. It creates a new, temporary `context_ptr_t` and assigns it to `local_context&`. But `local_context&`is an lvalue, meaning the function may modify the value and "return" the modified value to the caller. This modified value would be lost without warning if the caller passes a temporary.

#### Solution:
If you can, add a `const` to the reference.
```cpp
checkout_request(const context_ptr_t &local_context = context_ptr_t())
                 ^^^^^
{
    m_local_context= local_context;
}
```

### error C2440: 'initializing': cannot convert from 'litwindow::accessor' to 'litwindow::accessor &'

#### Description:
Another example of the same problem. The code is trying to pass a temporary object to a variable that only accepts a reference.
```cpp
accessor get_accessor()
{
   accessor rc;
   return rc; // return 'rc' as a temporary variable
}

//C2440: 'initializing' cannot
auto &ac(get_accessor());  // where get_accessor returns a temporary
```

#### Solution:
Change `auto &` to `const auto &`. The "[lifetime extension rules](https://stackoverflow.com/questions/17362673/temporary-lifetime-extension)" allow a temporary object to be assigned to a const reference.

```cpp
const auto &ac(get_accessor());
```

The lifetime of the return value
