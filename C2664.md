### C2664 'xx': cannot convert argument 2 from 'xx' to 'xx &' (with) note: A non-const reference may only be bound to an lvalue
Similar to C2440.

```cpp
ar << boost::serialization::make_nvp("pp", parameter_path.substr(prefix_length));
```
#### Description:
```cpp
template <typename T> make_nvp(const char*, T&>
```
The template method `make_nvp` has a `T&` as the second parameter. Here we pass a `string::substr` to it. `substr` returns a temporary `std::string`. This was accepted in older compiler versions, but goes against the C++ standard.

#### Solution:
We cannot modify `make_nvp`s signature. It's a boost library function to which we have no access. The only alternative here is to explicitly create a temporary variable and pass the variable to the method.
```cpp
auto parameter_substr = parameter_path.substr(prefix_length);
ar << boost::serialization::make_nvp("pp", parameter_substr);
```

#### Details:
This is actually a great example why the C++ language does not allow passing a temporary to non-const reference, even though we have to invent a temporary variable here to solve the problem.

The example is taken from a `serialize` function used with the `boost-serialization` library. The `serialize` function is a template function that defines how a struct is transferred from or to an archive. `make_nvp` creates a thin wrapper around parameter two and adds a *tag* to the parameter. It is used with XML archives for example. Here the serialize function reads or writes a substr of a parameter_path. It uses `make_nvp` to add the *tag* `pp` to the value. The result in XML would look like this:
```xml
<pp>parsubstr</pp>
```
Actually, the code that triggered the error, only writes the value. There is no read operation. So `ar && make_nvp("pp", parameter_path.substr(prefix_length))` poses no real problem. `make_nvp` creates a wrapper around the (temporary) result of `substr(prefix_length)`, attaches the tag `pp` to it and calls the `ar` archive to write the value to the output. Once this is done, the wrapper gets discared, the (temporary) result gets discarded and code execution continues. All is well.

But the same code might also be used to *read* the XML archive `<pp>parsubstr</pp>`. Let's see what would happen.

1. `parameter_path.substr(prefix_length)` returns a temporary string containing the `substr`.
1. `make_nvp("pp", ...)` would create a wrapper around the temporary value.
1. `ar && make_nvp...` would read the XML archive and store the data in the wrapper, which would transfer it to the temporary value it was created for.
1. Then the wrapper would get destroyed and finally
1. the temporary value would get destroyed as well

But the temporary value would be destroyed before any code had the chance to actually do something with the data from the archive. The `make_nvp` accepts non-const reference because it stores it to let the archive manipulate the lvalue. Since we've passed a temporary to `make_nvp`, any manipulation will be lost and the code will have no effect.

Obviously it is an error to pass a temporary variable to a read function. The read function should read something and return the data. It makes no sense to discard the returned data before doing anything.

Previously this kind of error could go unnoticed, because the compiler would happily accept a temporary for non-const reference and wouldn't even give a warning. The code would have done nothing useful, but at first glance it would look fine.

By requiring an lvalue (== refusing a temporary object) for a non-const reference the compiler will prevent this kind of error. BTW, it is not the only reason why the standard does not allow it. Search for temporary, lvalue, if you want to know more.

Unfortunately, there is only one variant of `make_nvp`. Actually the library should have an overload `make_nvp(const char*, const T&)` which we could use in cases where we *know*, we will be writing only. Since there is not, we have to create a temporary variable ourselves and pass it to the `make_nvp` call. The compiler will be happy, the contents will still be discarded, but only after the serialization and visibly for us, instead of silently.
